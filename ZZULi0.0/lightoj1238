#include <bits/stdc++.h>
#define N 25
using namespace std;

int visit[N][N][4],dir[4][2] = { {0,1},{0,-1}, {1,0},{-1,0}};
char maze[N][N];
int m,n;
struct nodes
{
    int x,y,step;
}tmp,cur,a,b,c,h;

bool judge(int x,int y,int pos)
{
    if(x < 0 || x >= m || y < 0 || y >= n || visit[x][y][pos] != 0)
        return false;
    return true;
}
void bfs(nodes st,int pos)
{
    visit[st.x][st.y][pos] = 1;
    queue<nodes>Q;
    st.step = 0;
    Q.push(st);
    while(!Q.empty())
    {
        cur = Q.front();
        Q.pop();
        if(cur.x == h.x && cur.y == h.y) return;

        for(int i = 0 ; i < 4; i++)
        {
            tmp.x = cur.x + dir[i][0];
            tmp.y = cur.y + dir[i][1];
            tmp.step = cur.step + 1;
            if(judge(tmp.x,tmp.y,pos))
            {
                visit[tmp.x][tmp.y][pos] = tmp.step;
                Q.push(tmp);
            }
        }
    }
}

void solve()
{
    //int n,m;
    scanf("%d %d",&m,&n);
    for(int i = 0 ; i < m; i++)
        scanf("%s",maze[i]);
    memset(visit,0,sizeof(visit));
    for(int i = 0; i < m; i++)
    {
        for(int j = 0 ; j < n; j++)
        {
            if(maze[i][j] == '#' || maze[i][j] == 'm')
                {
                    for(int k = 0; k < 3; k++)
                        visit[i][j][k] = 1;
                }
            else if(maze[i][j] == 'a')
                a.x = i,a.y = j;
            else if(maze[i][j] == 'b')
                b.x = i,b.y = j;
            else if(maze[i][j] == 'c')
                c.x = i,c.y = j;
            else if(maze[i][j] == 'h')
                h.x = i,h.y = j;
        }
    }
    bfs(a,0);
    bfs(b,1);
    bfs(c,2);
    int ans = -1;
    for(int i = 0 ; i < 3 ; i++)
        ans = max(visit[h.x][h.y][i],ans);
    printf("%d\n",ans);

}
int main(void)
{
    int t,cnt = 0;
    scanf("%d",&t);
    while(t--)
    {
        printf("Case %d: ",++cnt);
        solve();
    }
    return 0;
}
